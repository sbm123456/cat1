var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// packages/plugin-schedule/src/index.ts
__export(exports, {
  apply: () => apply,
  name: () => name
});
var import_koishi_core = __toModule(require("koishi-core"));
var import_koishi_utils = __toModule(require("koishi-utils"));
import_koishi_core.Tables.extend("schedule", {
  type: "incremental",
  fields: {
    id: { type: "integer" },
    assignee: { type: "string", length: 50 },
    time: { type: "timestamp" },
    lastCall: { type: "timestamp" },
    interval: { type: "integer", length: 20, initial: 0 },
    command: { type: "string", length: 1e3 },
    session: { type: "json" }
  }
});
var logger = new import_koishi_utils.Logger("schedule");
function formatContext(session) {
  return session.subtype === "private" ? `私聊 ${session.userId}` : `群聊 ${session.groupId}`;
}
var name = "schedule";
function apply(ctx, config = {}) {
  const { database } = ctx;
  const { minInterval = import_koishi_utils.Time.minute } = config;
  async function hasSchedule(id) {
    const data = await database.get("schedule", [id]);
    return data.length;
  }
  async function prepareSchedule({ id, session, interval, command, time, lastCall }) {
    const now = Date.now();
    const date = time.valueOf();
    async function executeSchedule() {
      logger.debug("execute %d: %c", id, command);
      await session.execute(command);
      if (!lastCall || !interval)
        return;
      lastCall = new Date();
      await database.update("schedule", [{ id, lastCall }]);
    }
    if (!interval) {
      if (date < now) {
        database.remove("schedule", [id]);
        if (lastCall)
          executeSchedule();
        return;
      }
      logger.debug("prepare %d: %c at %s", id, command, time);
      return ctx.setTimeout(async () => {
        if (!await hasSchedule(id))
          return;
        database.remove("schedule", [id]);
        executeSchedule();
      }, date - now);
    }
    logger.debug("prepare %d: %c from %s every %s", id, command, time, import_koishi_utils.Time.formatTimeShort(interval));
    const timeout = date < now ? interval - (now - date) % interval : date - now;
    if (lastCall && timeout + now - interval > +lastCall) {
      executeSchedule();
    }
    ctx.setTimeout(async () => {
      if (!await hasSchedule(id))
        return;
      const dispose = ctx.setInterval(async () => {
        if (!await hasSchedule(id))
          return dispose();
        executeSchedule();
      }, interval);
      executeSchedule();
    }, timeout);
  }
  ctx.on("connect", async () => {
    const schedules = await database.get("schedule", { assignee: ctx.bots.map((bot) => bot.sid) });
    schedules.forEach((schedule) => {
      const { session, assignee } = schedule;
      if (!ctx.bots[assignee])
        return;
      schedule.session = new import_koishi_core.Session(ctx.app, session);
      prepareSchedule(schedule);
    });
  });
  ctx.command("schedule [time]", "设置定时命令", { authority: 3, checkUnknown: true }).option("rest", "-- <command:text>  要执行的指令").option("interval", "/ <interval:string>  设置触发的间隔秒数", { authority: 4 }).option("list", "-l  查看已经设置的日程").option("ensure", "-e  错过时间也确保执行").option("full", "-f  查找全部上下文", { authority: 4 }).option("delete", "-d <id>  删除已经设置的日程").action(async ({ session, options }, ...dateSegments) => {
    if (options.delete) {
      await database.remove("schedule", [options.delete]);
      return `日程 ${options.delete} 已删除。`;
    }
    if (options.list) {
      let schedules = await database.get("schedule", { assignee: [session.sid] });
      if (!options.full) {
        schedules = schedules.filter((s) => session.channelId === s.session.channelId);
      }
      if (!schedules.length)
        return "当前没有等待执行的日程。";
      return schedules.map(({ id, time: time2, interval: interval2, command, session: session2 }) => {
        let output = `${id}. ${import_koishi_utils.Time.formatTimeInterval(time2, interval2)}：${command}`;
        if (options.full)
          output += `，上下文：${formatContext(session2)}`;
        return output;
      }).join("\n");
    }
    if (!options.rest)
      return "请输入要执行的指令。";
    const dateString = dateSegments.join("-");
    const time = import_koishi_utils.Time.parseDate(dateString);
    const timestamp = +time;
    if (Number.isNaN(timestamp) || timestamp > 2147483647e3) {
      if (/^\d+$/.test(dateString)) {
        return `请输入合法的日期。你要输入的是不是 ${dateString}s？`;
      } else {
        return "请输入合法的日期。";
      }
    } else if (!options.interval) {
      if (!dateString) {
        return "请输入执行时间。";
      } else if (timestamp <= Date.now()) {
        return "不能指定过去的时间为执行时间。";
      }
    }
    const interval = import_koishi_utils.Time.parseTime(options.interval);
    if (!interval && options.interval) {
      return "请输入合法的时间间隔。";
    } else if (interval && interval < minInterval) {
      return "时间间隔过短。";
    }
    const schedule = await database.create("schedule", {
      time,
      assignee: session.sid,
      interval,
      command: options.rest,
      session: session.toJSON()
    });
    schedule.session = session;
    prepareSchedule(schedule);
    return `日程已创建，编号为 ${schedule.id}。`;
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  apply,
  name
});
//# sourceMappingURL=index.js.map
